import {
  require_react_table
} from "./chunk-TJ3ZQOPP.js";
import {
  require_react
} from "./chunk-ZVMIEU5R.js";
import {
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/react-table-plugins/dist/index.es.js
var import_react = __toESM(require_react());
var import_react_table = __toESM(require_react_table());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function sum(values, aggregatedValues) {
  return (aggregatedValues || values).reduce(function(sum2, next) {
    return sum2 + (typeof next === "number" ? next : 0);
  }, 0);
}
function min(values) {
  var min2 = 0;
  values.forEach(function(value) {
    if (typeof value === "number") {
      min2 = Math.min(min2, value);
    }
  });
  return min2;
}
function max(values) {
  var max2 = 0;
  values.forEach(function(value) {
    if (typeof value === "number") {
      max2 = Math.max(max2, value);
    }
  });
  return max2;
}
function minMax(values) {
  var min2 = 0;
  var max2 = 0;
  values.forEach(function(value) {
    if (typeof value === "number") {
      min2 = Math.min(min2, value);
      max2 = Math.max(max2, value);
    }
  });
  return min2 + ".." + max2;
}
function average(values) {
  return sum(null, values) / values.length;
}
function median(values) {
  if (!values.length) {
    return null;
  }
  var min2 = 0;
  var max2 = 0;
  values.forEach(function(value) {
    if (typeof value === "number") {
      min2 = Math.min(min2, value);
      max2 = Math.max(max2, value);
    }
  });
  return (min2 + max2) / 2;
}
function unique(values) {
  return [].concat(new Set(values).values());
}
function uniqueCount(values) {
  return new Set(values).size;
}
function count(values) {
  return values.length;
}
var aggregations = Object.freeze({
  __proto__: null,
  sum,
  min,
  max,
  minMax,
  average,
  median,
  unique,
  uniqueCount,
  count
});
function getFirstDefined() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  for (var i = 0; i < args.length; i += 1) {
    if (typeof args[i] !== "undefined") {
      return args[i];
    }
  }
}
import_react_table.actions.resetColumnSummary = "resetColumnSummary";
import_react_table.actions.setColumnSummary = "setColumnSummary";
var useColumnSummary = function useColumnSummary2(hooks) {
  hooks.stateReducers.push(reducer);
  hooks.useInstance.push(useInstance);
};
useColumnSummary.pluginName = "useColumnSummary";
var defaultUserColumnSummaryFns = {};
var defaultColumnSummaryFn = "count";
function reducer(state, action, previousState, instance) {
  if (action.type === import_react_table.actions.init) {
    return _extends({
      columnSummary: {}
    }, state);
  }
  if (action.type === import_react_table.actions.resetColumnSummary) {
    return _extends({}, state, {
      columnSummary: instance.initialState.columnSummary || {}
    });
  }
  if (action.type === import_react_table.actions.setColumnSummary) {
    return _extends({}, state, {
      columnSummary: (0, import_react_table.functionalUpdate)(action.columnSummary, state.columnSummary)
    });
  }
}
function useInstance(instance) {
  var columnSummary = instance.state.columnSummary, allColumns = instance.allColumns, rows = instance.rows, _instance$columnSumma = instance.columnSummaryFns, userColumnSummaryFns = _instance$columnSumma === void 0 ? defaultUserColumnSummaryFns : _instance$columnSumma, dispatch = instance.dispatch, disableColumnSummary = instance.disableColumnSummary;
  var setColumnSummary = import_react.default.useCallback(function(columnSummary2) {
    return dispatch({
      type: import_react_table.actions.setColumnSummary,
      columnSummary: columnSummary2
    });
  }, [dispatch]);
  import_react.default.useMemo(function() {
    allColumns.forEach(function(column) {
      var id = column.id, accessor = column.accessor, _column$columnSummary = column.columnSummaryFn, columnSummaryFn = _column$columnSummary === void 0 ? defaultColumnSummaryFn : _column$columnSummary;
      column.hasColumnSummary = accessor ? getFirstDefined(column.disableColumnSummary === true ? false : void 0, disableColumnSummary === true ? false : void 0, true) : false;
      var columnSummaryType = columnSummary[id] || columnSummaryFn;
      var summaryFn = typeof columnSummaryType === "function" ? columnSummaryType : userColumnSummaryFns[columnSummaryType] || aggregations[columnSummaryType];
      var columnSummaryValue = null;
      if (summaryFn) {
        columnSummaryValue = summaryFn(rows.map(function(d) {
          return d.values[column.id];
        }));
      } else if (columnSummaryType) {
        console.info({
          column
        });
        throw new Error("React Table: Invalid columnSummary function provided for column listed above");
      }
      column.columnSummary = {
        type: columnSummaryType,
        value: columnSummaryValue
      };
      column.setColumnSummary = function(data) {
        var _extends2;
        setColumnSummary(_extends({}, columnSummary, (_extends2 = {}, _extends2[id] = data, _extends2)));
      };
    });
  }, [allColumns, setColumnSummary, columnSummary, userColumnSummaryFns, rows, disableColumnSummary]);
  Object.assign(instance, {
    setColumnSummary
  });
}
var defaultGetExportFileName = function defaultGetExportFileName2(_ref) {
  var fileType = _ref.fileType, all = _ref.all;
  return (all ? "all-" : "") + "data";
};
var defaultGetColumnExportValue = function defaultGetColumnExportValue2(col) {
  var name = col.Header;
  if (typeof name === "object" || typeof name === "function") {
    name = col.id;
  }
  return name;
};
var defaultGetCellExportValue = function defaultGetCellExportValue2(row, col) {
  return row.values[col.id];
};
var defaultGetExportFileBlob = function defaultGetExportFileBlob2() {
  throw new Error("React Table: Export Blob is mandatory");
};
var useExportData = function useExportData2(hooks) {
  hooks.useInstance.push(useInstance$1);
};
useExportData.pluginName = "useExportData";
function useInstance$1(instance) {
  var rows = instance.rows, _instance$initialRows = instance.initialRows, initialRows = _instance$initialRows === void 0 ? [] : _instance$initialRows, allColumns = instance.allColumns, disableExport = instance.disableExport, _instance$getExportFi = instance.getExportFileName, getExportFileName = _instance$getExportFi === void 0 ? defaultGetExportFileName : _instance$getExportFi, _instance$getExportFi2 = instance.getExportFileBlob, getExportFileBlob = _instance$getExportFi2 === void 0 ? defaultGetExportFileBlob : _instance$getExportFi2, plugins = instance.plugins;
  (0, import_react_table.ensurePluginOrder)(plugins, ["useColumnOrder", "useColumnVisibility", "useFilters", "useSortBy"], "useExportData");
  allColumns.forEach(function(column) {
    var accessor = column.accessor, _column$getColumnExpo = column.getColumnExportValue, getColumnExportValue = _column$getColumnExpo === void 0 ? defaultGetColumnExportValue : _column$getColumnExpo;
    var canExport = accessor ? getFirstDefined(column.disableExport === true ? false : void 0, disableExport === true ? false : void 0, true) : false;
    column.canExport = canExport;
    column.exportValue = getColumnExportValue(column);
  });
  var exportData = import_react.default.useCallback(function(fileType, all) {
    if (all === void 0) {
      all = false;
    }
    var exportableColumns = allColumns.filter(function(col) {
      return col.canExport && (all || col.isVisible);
    });
    if (exportableColumns.length === 0) {
      console.warn("No exportable columns are available");
    }
    var exportableRows = (all ? initialRows : rows).map(function(row) {
      return exportableColumns.map(function(col) {
        var _col$getCellExportVal = col.getCellExportValue, getCellExportValue = _col$getCellExportVal === void 0 ? defaultGetCellExportValue : _col$getCellExportVal;
        return getCellExportValue(row, col);
      });
    });
    var fileName = getExportFileName({
      fileType,
      all
    });
    var fileBlob = getExportFileBlob({
      columns: exportableColumns,
      data: exportableRows,
      fileName,
      fileType
    });
    if (fileBlob) {
      downloadFileViaBlob(fileBlob, fileName, fileType);
    }
  }, [getExportFileBlob, getExportFileName, initialRows, rows, allColumns]);
  Object.assign(instance, {
    exportData
  });
}
function downloadFileViaBlob(fileBlob, fileName, type) {
  if (fileBlob) {
    var dataUrl = URL.createObjectURL(fileBlob);
    var link = document.createElement("a");
    link.download = fileName + "." + type;
    link.href = dataUrl;
    link.click();
  }
}
import_react_table.actions.cellRangeSelectionStart = "cellRangeSelectionStart";
import_react_table.actions.cellRangeSelecting = "cellRangeSelecting";
import_react_table.actions.cellRangeSelectionEnd = "cellRangeSelectionEnd";
import_react_table.actions.setSelectedCellIds = "setSelectedCellIds";
var useCellRangeSelection = function useCellRangeSelection2(hooks) {
  hooks.getCellRangeSelectionProps = [defaultgetCellRangeSelectionProps];
  hooks.stateReducers.push(reducer$1);
  hooks.useInstance.push(useInstance$2);
  hooks.prepareRow.push(prepareRow);
};
useCellRangeSelection.pluginName = "useCellRangeSelection";
var defaultgetCellRangeSelectionProps = function defaultgetCellRangeSelectionProps2(props, _ref) {
  var instance = _ref.instance, cell = _ref.cell;
  var isSelectingCells = instance.state.isSelectingCells, dispatch = instance.dispatch;
  var start = function start2(startCell, event) {
    return dispatch({
      type: import_react_table.actions.cellRangeSelectionStart,
      startCell,
      event
    });
  };
  var selecting = function selecting2(selectingEndCell, event) {
    return dispatch({
      type: import_react_table.actions.cellRangeSelecting,
      selectingEndCell,
      event
    });
  };
  var end = function end2(endCell, event) {
    return dispatch({
      type: import_react_table.actions.cellRangeSelectionEnd,
      endCell,
      event
    });
  };
  return [props, {
    onMouseDown: function onMouseDown(e) {
      e.persist();
      start(cell.id, e);
    },
    onMouseUp: function onMouseUp(e) {
      e.persist();
      end(cell.id, e);
    },
    onMouseEnter: function onMouseEnter(e) {
      if (isSelectingCells) {
        e.persist();
        selecting(cell.id, e);
      }
    }
  }];
};
function reducer$1(state, action, previousState, instance) {
  if (action.type === import_react_table.actions.init) {
    return _extends({}, state, {
      selectedCellIds: _extends({}, instance.initialState.selectedCellIds) || {},
      isSelectingCells: false,
      startCellSelection: null,
      endCellSelection: null,
      currentSelectedCellIds: {}
    });
  }
  if (action.type === import_react_table.actions.cellRangeSelectionStart) {
    var startCell = action.startCell, event = action.event;
    var newState = Object.assign(state.selectedCellIds, {});
    if (event.ctrlKey === true) {
      if (newState[startCell]) {
        delete newState[startCell];
      } else {
        newState[startCell] = true;
      }
    } else {
      newState = {};
    }
    return _extends({}, state, {
      selectedCellIds: _extends({}, newState) || {},
      isSelectingCells: true,
      startCellSelection: startCell
    });
  }
  if (action.type === import_react_table.actions.cellRangeSelecting) {
    var selectingEndCell = action.selectingEndCell;
    var startCellSelection = instance.state.startCellSelection, getCellsBetweenId = instance.getCellsBetweenId;
    var _newState = getCellsBetweenId(startCellSelection, selectingEndCell);
    return _extends({}, state, {
      endCellSelection: selectingEndCell,
      currentSelectedCellIds: _newState
    });
  }
  if (action.type === import_react_table.actions.cellRangeSelectionEnd) {
    var _instance$state = instance.state, selectedCellIds = _instance$state.selectedCellIds, currentSelectedCellIds = _instance$state.currentSelectedCellIds;
    return _extends({}, state, {
      selectedCellIds: _extends({}, selectedCellIds, currentSelectedCellIds),
      isSelectingCells: false,
      currentSelectedCellIds: {},
      startCellSelection: null,
      endCellSelection: null
    });
  }
  if (action.type === import_react_table.actions.setSelectedCellIds) {
    var _selectedCellIds = (0, import_react_table.functionalUpdate)(action.selectedCellIds, state.selectedCellIds);
    return _extends({}, state, {
      selectedCellIds: _selectedCellIds
    });
  }
}
function useInstance$2(instance) {
  var dispatch = instance.dispatch, allColumns = instance.allColumns, rows = instance.rows;
  var cellsById = {};
  var defaultCellIdSplitBy = "_col_row_";
  var cellIdSplitBy = instance.cellIdSplitBy || defaultCellIdSplitBy;
  Object.assign(instance, {
    cellIdSplitBy
  });
  var setSelectedCellIds = import_react.default.useCallback(function(selectedCellIds) {
    return dispatch({
      type: import_react_table.actions.setSelectedCellIds,
      selectedCellIds
    });
  }, [dispatch]);
  var getCellsBetweenId = import_react.default.useCallback(function(startCell, endCell) {
    if (!cellsById[startCell] || !cellsById[endCell]) {
      console.info({
        startCell,
        endCell
      });
      throw new Error("React Table: startCellId and endCellId has to be valid cell Id");
    }
    var rowsIndex = [cellsById[startCell].row.index, cellsById[endCell].row.index];
    var columnsIndex = [];
    allColumns.forEach(function(col, index) {
      if (col.id === cellsById[startCell].column.id || col.id === cellsById[endCell].column.id) {
        columnsIndex.push(index);
      }
    });
    var selectedColumns = [];
    var selectedRows = [];
    for (var i = Math.min.apply(Math, columnsIndex); i <= Math.max.apply(Math, columnsIndex); i++) {
      selectedColumns.push(allColumns[i].id);
    }
    for (var _i = Math.min.apply(Math, rowsIndex); _i <= Math.max.apply(Math, rowsIndex); _i++) {
      selectedRows.push(rows[_i].id);
    }
    var cellsBetween = {};
    if (selectedRows.length && selectedColumns.length) {
      for (var _i2 = 0; _i2 < selectedRows.length; _i2++) {
        for (var j = 0; j < selectedColumns.length; j++) {
          var id = selectedColumns[j] + cellIdSplitBy + selectedRows[_i2];
          var cell = cellsById[id];
          cellsBetween[cell.id] = true;
        }
      }
    }
    return cellsBetween;
  }, [allColumns, cellsById, cellIdSplitBy, rows]);
  Object.assign(instance, {
    getCellsBetweenId,
    cellsById,
    setSelectedCellIds
  });
}
function prepareRow(row, _ref2) {
  var _ref2$instance = _ref2.instance, cellsById = _ref2$instance.cellsById, cellIdSplitBy = _ref2$instance.cellIdSplitBy, instance = _ref2.instance;
  row.allCells.forEach(function(cell) {
    cell.id = cell.column.id + cellIdSplitBy + row.id;
    cellsById[cell.id] = cell;
    cell.getCellRangeSelectionProps = (0, import_react_table.makePropGetter)(instance.getHooks().getCellRangeSelectionProps, {
      instance,
      row,
      cell
    });
  });
}
export {
  useCellRangeSelection,
  useColumnSummary,
  useExportData
};
//# sourceMappingURL=react-table-plugins.js.map
