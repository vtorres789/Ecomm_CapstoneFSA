'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));
var reactTable = require('react-table');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function sum(values, aggregatedValues) {
  // It's faster to just add the aggregations together instead of
  // process leaf nodes individually
  return (aggregatedValues || values).reduce(function (sum, next) {
    return sum + (typeof next === 'number' ? next : 0);
  }, 0);
}
function min(values) {
  var min = 0;
  values.forEach(function (value) {
    if (typeof value === 'number') {
      min = Math.min(min, value);
    }
  });
  return min;
}
function max(values) {
  var max = 0;
  values.forEach(function (value) {
    if (typeof value === 'number') {
      max = Math.max(max, value);
    }
  });
  return max;
}
function minMax(values) {
  var min = 0;
  var max = 0;
  values.forEach(function (value) {
    if (typeof value === 'number') {
      min = Math.min(min, value);
      max = Math.max(max, value);
    }
  });
  return min + ".." + max;
}
function average(values) {
  return sum(null, values) / values.length;
}
function median(values) {
  if (!values.length) {
    return null;
  }

  var min = 0;
  var max = 0;
  values.forEach(function (value) {
    if (typeof value === 'number') {
      min = Math.min(min, value);
      max = Math.max(max, value);
    }
  });
  return (min + max) / 2;
}
function unique(values) {
  return [].concat(new Set(values).values());
}
function uniqueCount(values) {
  return new Set(values).size;
}
function count(values) {
  return values.length;
}

var aggregations = /*#__PURE__*/Object.freeze({
  __proto__: null,
  sum: sum,
  min: min,
  max: max,
  minMax: minMax,
  average: average,
  median: median,
  unique: unique,
  uniqueCount: uniqueCount,
  count: count
});

function getFirstDefined() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  for (var i = 0; i < args.length; i += 1) {
    if (typeof args[i] !== "undefined") {
      return args[i];
    }
  }
}

reactTable.actions.resetColumnSummary = "resetColumnSummary";
reactTable.actions.setColumnSummary = "setColumnSummary";
var useColumnSummary = function useColumnSummary(hooks) {
  hooks.stateReducers.push(reducer);
  hooks.useInstance.push(useInstance);
};
useColumnSummary.pluginName = "useColumnSummary";
var defaultUserColumnSummaryFns = {};
var defaultColumnSummaryFn = "count"; // Reducer

function reducer(state, action, previousState, instance) {
  if (action.type === reactTable.actions.init) {
    return _extends({
      columnSummary: {}
    }, state);
  }

  if (action.type === reactTable.actions.resetColumnSummary) {
    return _extends({}, state, {
      columnSummary: instance.initialState.columnSummary || {}
    });
  }

  if (action.type === reactTable.actions.setColumnSummary) {
    return _extends({}, state, {
      columnSummary: reactTable.functionalUpdate(action.columnSummary, state.columnSummary)
    });
  }
}

function useInstance(instance) {
  var columnSummary = instance.state.columnSummary,
      allColumns = instance.allColumns,
      rows = instance.rows,
      _instance$columnSumma = instance.columnSummaryFns,
      userColumnSummaryFns = _instance$columnSumma === void 0 ? defaultUserColumnSummaryFns : _instance$columnSumma,
      dispatch = instance.dispatch,
      disableColumnSummary = instance.disableColumnSummary;
  var setColumnSummary = React.useCallback(function (columnSummary) {
    return dispatch({
      type: reactTable.actions.setColumnSummary,
      columnSummary: columnSummary
    });
  }, [dispatch]);
  React.useMemo(function () {
    allColumns.forEach(function (column) {
      var id = column.id,
          accessor = column.accessor,
          _column$columnSummary = column.columnSummaryFn,
          columnSummaryFn = _column$columnSummary === void 0 ? defaultColumnSummaryFn : _column$columnSummary; // Determine if a column has summary

      column.hasColumnSummary = accessor ? getFirstDefined(column.disableColumnSummary === true ? false : undefined, disableColumnSummary === true ? false : undefined, true) : false;
      var columnSummaryType = columnSummary[id] || columnSummaryFn;
      var summaryFn = typeof columnSummaryType === "function" ? columnSummaryType : userColumnSummaryFns[columnSummaryType] || aggregations[columnSummaryType];
      var columnSummaryValue = null;

      if (summaryFn) {
        columnSummaryValue = summaryFn(rows.map(function (d) {
          return d.values[column.id];
        }));
      } else if (columnSummaryType) {
        console.info({
          column: column
        });
        throw new Error("React Table: Invalid columnSummary function provided for column listed above");
      }

      column.columnSummary = {
        type: columnSummaryType,
        value: columnSummaryValue
      }; // console.log(column);

      column.setColumnSummary = function (data) {
        var _extends2;

        setColumnSummary(_extends({}, columnSummary, (_extends2 = {}, _extends2[id] = data, _extends2)));
      };
    });
  }, [allColumns, setColumnSummary, columnSummary, userColumnSummaryFns, rows, disableColumnSummary]);
  Object.assign(instance, {
    setColumnSummary: setColumnSummary
  });
}

var defaultGetExportFileName = function defaultGetExportFileName(_ref) {
  var fileType = _ref.fileType,
      all = _ref.all;
  return (all ? "all-" : "") + "data";
}; // To get column name while exporting


var defaultGetColumnExportValue = function defaultGetColumnExportValue(col) {
  var name = col.Header;

  if (typeof name === "object" || typeof name === "function") {
    name = col.id;
  }

  return name;
}; // To get cell value while exporting


var defaultGetCellExportValue = function defaultGetCellExportValue(row, col) {
  return row.values[col.id];
};

var defaultGetExportFileBlob = function defaultGetExportFileBlob() {
  throw new Error("React Table: Export Blob is mandatory");
};

var useExportData = function useExportData(hooks) {
  hooks.useInstance.push(useInstance$1);
};
useExportData.pluginName = "useExportData";

function useInstance$1(instance) {
  var rows = instance.rows,
      _instance$initialRows = instance.initialRows,
      initialRows = _instance$initialRows === void 0 ? [] : _instance$initialRows,
      allColumns = instance.allColumns,
      disableExport = instance.disableExport,
      _instance$getExportFi = instance.getExportFileName,
      getExportFileName = _instance$getExportFi === void 0 ? defaultGetExportFileName : _instance$getExportFi,
      _instance$getExportFi2 = instance.getExportFileBlob,
      getExportFileBlob = _instance$getExportFi2 === void 0 ? defaultGetExportFileBlob : _instance$getExportFi2,
      plugins = instance.plugins;
  reactTable.ensurePluginOrder(plugins, ["useColumnOrder", "useColumnVisibility", "useFilters", "useSortBy"], "useExportData"); // Adding `canExport` & `exportValue` meta data

  allColumns.forEach(function (column) {
    var accessor = column.accessor,
        _column$getColumnExpo = column.getColumnExportValue,
        getColumnExportValue = _column$getColumnExpo === void 0 ? defaultGetColumnExportValue : _column$getColumnExpo;
    var canExport = accessor ? getFirstDefined(column.disableExport === true ? false : undefined, disableExport === true ? false : undefined, true) : false;
    column.canExport = canExport;
    column.exportValue = getColumnExportValue(column);
  }); // This method will enable export of data on `instance` object

  var exportData = React.useCallback(function (fileType, all) {
    if (all === void 0) {
      all = false;
    }

    // Columns which are exportable
    var exportableColumns = allColumns.filter(function (col) {
      return col.canExport && (all || col.isVisible);
    });

    if (exportableColumns.length === 0) {
      console.warn("No exportable columns are available");
    } // Rows which are exportable


    var exportableRows = (all ? initialRows : rows).map(function (row) {
      return exportableColumns.map(function (col) {
        var _col$getCellExportVal = col.getCellExportValue,
            getCellExportValue = _col$getCellExportVal === void 0 ? defaultGetCellExportValue : _col$getCellExportVal;
        return getCellExportValue(row, col);
      });
    }); // Getting fileName

    var fileName = getExportFileName({
      fileType: fileType,
      all: all
    }); // Get `FileBlob` to download

    var fileBlob = getExportFileBlob({
      columns: exportableColumns,
      data: exportableRows,
      fileName: fileName,
      fileType: fileType
    }); // Trigger download in browser

    if (fileBlob) {
      downloadFileViaBlob(fileBlob, fileName, fileType);
    }
  }, [getExportFileBlob, getExportFileName, initialRows, rows, allColumns]);
  Object.assign(instance, {
    exportData: exportData
  });
}

function downloadFileViaBlob(fileBlob, fileName, type) {
  if (fileBlob) {
    var dataUrl = URL.createObjectURL(fileBlob);
    var link = document.createElement("a");
    link.download = fileName + "." + type;
    link.href = dataUrl;
    link.click();
  }
}

reactTable.actions.cellRangeSelectionStart = 'cellRangeSelectionStart';
reactTable.actions.cellRangeSelecting = 'cellRangeSelecting';
reactTable.actions.cellRangeSelectionEnd = 'cellRangeSelectionEnd';
reactTable.actions.setSelectedCellIds = 'setSelectedCellIds'; // exposed to user on an instance

var useCellRangeSelection = function useCellRangeSelection(hooks) {
  hooks.getCellRangeSelectionProps = [defaultgetCellRangeSelectionProps];
  hooks.stateReducers.push(reducer$1);
  hooks.useInstance.push(useInstance$2);
  hooks.prepareRow.push(prepareRow);
};
useCellRangeSelection.pluginName = 'useCellRangeSelection';

var defaultgetCellRangeSelectionProps = function defaultgetCellRangeSelectionProps(props, _ref) {
  var instance = _ref.instance,
      cell = _ref.cell;
  var isSelectingCells = instance.state.isSelectingCells,
      dispatch = instance.dispatch; // These actions are not exposed on an instance, as we provide setSelectedCells and getCellsBetweenId.

  var start = function start(startCell, event) {
    return dispatch({
      type: reactTable.actions.cellRangeSelectionStart,
      startCell: startCell,
      event: event
    });
  };

  var selecting = function selecting(selectingEndCell, event) {
    return dispatch({
      type: reactTable.actions.cellRangeSelecting,
      selectingEndCell: selectingEndCell,
      event: event
    });
  };

  var end = function end(endCell, event) {
    return dispatch({
      type: reactTable.actions.cellRangeSelectionEnd,
      endCell: endCell,
      event: event
    });
  };

  return [props, {
    onMouseDown: function onMouseDown(e) {
      e.persist(); // event-pooling

      start(cell.id, e);
    },
    onMouseUp: function onMouseUp(e) {
      e.persist();
      end(cell.id, e);
    },
    onMouseEnter: function onMouseEnter(e) {
      if (isSelectingCells) {
        e.persist();
        selecting(cell.id, e);
      }
    }
  }];
}; // currentSelectedCellIds: Is for currently selected range
// selectedCellIds: Contains all selected cells
// On cellRangeSelectionEnd: we move currentSelectedCellIds to selectedCellIds


function reducer$1(state, action, previousState, instance) {
  if (action.type === reactTable.actions.init) {
    return _extends({}, state, {
      selectedCellIds: _extends({}, instance.initialState.selectedCellIds) || {},
      isSelectingCells: false,
      startCellSelection: null,
      endCellSelection: null,
      currentSelectedCellIds: {}
    });
  }

  if (action.type === reactTable.actions.cellRangeSelectionStart) {
    var startCell = action.startCell,
        event = action.event;
    var newState = Object.assign(state.selectedCellIds, {});

    if (event.ctrlKey === true) {
      if (newState[startCell]) {
        delete newState[startCell];
      } else {
        newState[startCell] = true;
      }
    } else {
      newState = {};
    }

    return _extends({}, state, {
      selectedCellIds: _extends({}, newState) || {},
      isSelectingCells: true,
      startCellSelection: startCell
    });
  }

  if (action.type === reactTable.actions.cellRangeSelecting) {
    var selectingEndCell = action.selectingEndCell;
    var startCellSelection = instance.state.startCellSelection,
        getCellsBetweenId = instance.getCellsBetweenId; // Get cells between cell ids (range)

    var _newState = getCellsBetweenId(startCellSelection, selectingEndCell);

    return _extends({}, state, {
      endCellSelection: selectingEndCell,
      currentSelectedCellIds: _newState
    });
  }

  if (action.type === reactTable.actions.cellRangeSelectionEnd) {
    var _instance$state = instance.state,
        selectedCellIds = _instance$state.selectedCellIds,
        currentSelectedCellIds = _instance$state.currentSelectedCellIds;
    return _extends({}, state, {
      selectedCellIds: _extends({}, selectedCellIds, currentSelectedCellIds),
      isSelectingCells: false,
      currentSelectedCellIds: {},
      startCellSelection: null,
      endCellSelection: null
    });
  }

  if (action.type === reactTable.actions.setSelectedCellIds) {
    var _selectedCellIds = reactTable.functionalUpdate(action.selectedCellIds, state.selectedCellIds);

    return _extends({}, state, {
      selectedCellIds: _selectedCellIds
    });
  }
}

function useInstance$2(instance) {
  var dispatch = instance.dispatch,
      allColumns = instance.allColumns,
      rows = instance.rows;
  var cellsById = {}; // make user control the cellIdSplitter

  var defaultCellIdSplitBy = '_col_row_';
  var cellIdSplitBy = instance.cellIdSplitBy || defaultCellIdSplitBy;
  Object.assign(instance, {
    cellIdSplitBy: cellIdSplitBy
  });
  var setSelectedCellIds = React.useCallback(function (selectedCellIds) {
    return dispatch({
      type: reactTable.actions.setSelectedCellIds,
      selectedCellIds: selectedCellIds
    });
  }, [dispatch]); // Returns all cells between Range ( between startcell and endcell Ids)

  var getCellsBetweenId = React.useCallback(function (startCell, endCell) {
    if (!cellsById[startCell] || !cellsById[endCell]) {
      console.info({
        startCell: startCell,
        endCell: endCell
      });
      throw new Error("React Table: startCellId and endCellId has to be valid cell Id");
    } // get rows and columns index boundaries


    var rowsIndex = [cellsById[startCell].row.index, cellsById[endCell].row.index];
    var columnsIndex = [];
    allColumns.forEach(function (col, index) {
      if (col.id === cellsById[startCell].column.id || col.id === cellsById[endCell].column.id) {
        columnsIndex.push(index);
      }
    }); // all selected rows and selected columns

    var selectedColumns = [];
    var selectedRows = [];

    for (var i = Math.min.apply(Math, columnsIndex); i <= Math.max.apply(Math, columnsIndex); i++) {
      selectedColumns.push(allColumns[i].id);
    }

    for (var _i = Math.min.apply(Math, rowsIndex); _i <= Math.max.apply(Math, rowsIndex); _i++) {
      selectedRows.push(rows[_i].id);
    } // select cells


    var cellsBetween = {};

    if (selectedRows.length && selectedColumns.length) {
      for (var _i2 = 0; _i2 < selectedRows.length; _i2++) {
        for (var j = 0; j < selectedColumns.length; j++) {
          var id = selectedColumns[j] + cellIdSplitBy + selectedRows[_i2];
          var cell = cellsById[id];
          cellsBetween[cell.id] = true;
        }
      }
    }

    return cellsBetween;
  }, [allColumns, cellsById, cellIdSplitBy, rows]);
  Object.assign(instance, {
    getCellsBetweenId: getCellsBetweenId,
    cellsById: cellsById,
    setSelectedCellIds: setSelectedCellIds
  });
}

function prepareRow(row, _ref2) {
  var _ref2$instance = _ref2.instance,
      cellsById = _ref2$instance.cellsById,
      cellIdSplitBy = _ref2$instance.cellIdSplitBy,
      instance = _ref2.instance;
  row.allCells.forEach(function (cell) {
    cell.id = cell.column.id + cellIdSplitBy + row.id;
    cellsById[cell.id] = cell;
    cell.getCellRangeSelectionProps = reactTable.makePropGetter(instance.getHooks().getCellRangeSelectionProps, {
      instance: instance,
      row: row,
      cell: cell
    });
  });
}

exports.useCellRangeSelection = useCellRangeSelection;
exports.useColumnSummary = useColumnSummary;
exports.useExportData = useExportData;
//# sourceMappingURL=index.js.map
